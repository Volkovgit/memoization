Мемоизация нужна для сохранение результата прошлого выполнения функции для предотвращения повторных вычислений


Как пример - замыкание с объектом внутри, хранящим в себе ранее вычесленные значения.






TDD : суть заключается в написании модульных тестов до начала разработки. Сокращает время на рефактор кода в случае неправильной работы кода.
Интеграционное тестирование проверяет что несколько компонентов системы работают нормально.
Модульное(юнит) тестирование позваоляет проверить на корректность отдельные модули. Идея в написании тестов для каждой нетривиальной функции
Основные правила:
    1)Быть достоверным
    2)Не зависеть от окружения
    3)Легко поддерживаются
    4)Легко читать и поддерживать






Data types and data structures:
    Reference type : function,objects,array




ECMAScript 6:
    1) Constant EXAMPLE_CONST = 'test';
    2) Block-Scoped Variables|Function - переменные в блоках могут быть одинаковые но с разными значениями. Аналогично с функциями, в других блоках кода можно переопределять функции и переменные.
    3) Arrow function
        +) odds = even.map(v=>v+1)
        -) odds = even.map(function())




Testing Best Practies
    1) Тесты должны быть понятны любым людям вне зависимости от специализации
        1) Что тестируется?
        2) Какой сценарий?
        3) Какой результат?
    2) ААА паттерн для структуризации
        Arrange Act Assert:
            Arrange: весь код должен быть смоделирован(подключение к БД/Создание экземпляра и т.д)
            Act: запуск тестируемого кода (1 строка)
            Assert: Удостоверьтесь что полученное значение совпадает 
    3) Использовать BDD-style assertions
        Кодить в декларативном стиле(КАКОЙ результат нужен а не КАК его добиться)
    4) Тестируем public методы (итоговые, не нужно проверять внутренние методы работы)
    5) Использовать реалистичные данные(генераторы различных данных)
    6) Убираем все лишнее. (200+ строковый json объект скорее всего не нужен нам для тестов, оставляем только необходимые данные для проверки)
    7) Не ловить ошибки, а ожидать их (в библиотеках есть методы на тестирование ошибок)
    8) Разбивать наши тесты на подкатегории